<html>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
        <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
            }
        }
        </script>

        <script type="x-shader/x-fragment" id="first_pass_fragmentshader">
            // First pass - transform points by a 3x3 matrix (a 4x4 is not necessary as it only
            // adds a constant value to depth). Write depth (R) and index (G).

            uniform mat3 transform;
            uniform sampler2D pointTexture;
            uniform vec2 res;

			void main() {
                ivec2 icoord = ivec2(gl_FragCoord.xy - 0.5); // integer texel coordinate
                int index = int(icoord.y * int(res.x) + icoord.x);
                vec4 point = texelFetch(pointTexture, icoord, 0);
                vec3 point_transformed = transform * point.xyz; // Assuming compiler will discard x/y automatically.
                gl_FragColor = vec4(point_transformed.z, float(index), 0.0, 1.0);
			}
		</script>        

        <script type="x-shader/x-fragment" id="bitonic_fragmentshader">
            // Bitonic sort. See picture in https://en.wikipedia.org/wiki/Bitonic_sorter#How_the_algorithm_works
            // More discussion in https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms/chapter-46-improved-gpu-sorting

            uniform sampler2D listTexture; // r is key to sort by, g is value (index).
            uniform vec2 res;
            uniform vec2 kj; // the k and j indices of the pass. // todo: how to pass int values?

			void main() {
                ivec2 icoord = ivec2(gl_FragCoord.xy - 0.5); // integer texel coordinate
                int i = int(icoord.y * int(res.x) + icoord.x);
                int k = int(kj.r);
                int j = int(kj.g);

                // python code:
                // is_green_box = (i // k) % 2 == 1
                // is_top_of_red_box = (i % (j * 2)) < j  # j is size of half of red box.
                // if is_green_box:
                //     compare_dir = -1 if is_top_of_red_box else +1
                //     l = i - j * compare_dir
                // else:
                //     compare_dir = +1 if is_top_of_red_box else -1
                //     l = i + j * compare_dir
                // max_il = max(arr[i], arr[l])
                // min_il = min(arr[i], arr[l])
                // result[i] = min_il if compare_dir > 0 else max_il

                // assuming compiler will optimize repeated conversions and branching. Anyway, ALU should not
                // be the bottleneck, memory access should be the bottleneck.
                int is_green_box = int(mod(float(i / k), 2.0));
                int is_top_of_red_box = mod(float(i), float(j) * 2.0) < float(j) ? 1 : 0;
                
                int compare_dir = is_green_box != 0 ? 
                        (is_top_of_red_box != 0 ? -1 : +1) : 
                        (is_top_of_red_box != 0 ? +1 : -1);
                
                int l = is_green_box != 0 ? i - j * compare_dir : i + j * compare_dir;
                
                ivec2 lcoord = ivec2(int(mod(float(l), res.x)), int(floor(float(l) / res.x)));
        
                vec4 listItem_i = texelFetch(listTexture, icoord, 0);
                vec4 listItem_l = texelFetch(listTexture, lcoord, 0);

                if (compare_dir > 0) {
                    // choose min value.
                    gl_FragColor = vec4(listItem_i.r < listItem_l.r ? listItem_i.rg : listItem_l.rg, 0.0, 1.0);
                } else {
                    // choose max value.
                    gl_FragColor = vec4(listItem_i.r > listItem_l.r ? listItem_i.rg : listItem_l.rg, 0.0, 1.0);
                }
			}
		</script>        

        <script type="module">

import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Starting point: https://stackoverflow.com/questions/75565926/threejs-pingpong-approach-for-rendering-to-texture-no-errors-nothing-renderin

var scene;
var camera;
var renderer;
var numPointsX = 64;
var numPointsY = 64;
var stride = 4;

var pointBuffer;
var pointTexture;
var textureA;
var textureB;

var firstPassMaterial;
var firstPassObject;
var firstPassScene;

var bitonicPassMaterial;
var bitonicPassObject;
var bitonicPassScene;

var finalMaterial;

var plane = new THREE.PlaneGeometry( numPointsX, numPointsY );

function pointTextureSetup() {
    pointBuffer = new Float32Array(numPointsX * numPointsY * stride);

    const boxSize = 2;
    const rng = new Math.seedrandom(1);
    for (let i = 0; i < pointBuffer.length; i++) {
        pointBuffer[i] = rng.quick() * boxSize * 2 - boxSize;
        // pointBuffer[i] = Math.round((rng.quick() * boxSize * 2) * 100) + 100;
    }
    // console.log(pointBuffer);

    pointTexture = new THREE.DataTexture( pointBuffer, 
        /*width=*/numPointsX * stride / 4, /*height=*/numPointsY, 
        /*format=*/THREE.RGBAFormat, /*type=*/THREE.FloatType,
        /*mapping=*/THREE.UVMapping, 
        /*wrapS=*/THREE.ClampToEdgeWrapping, /*wrapT=*/THREE.ClampToEdgeWrapping,
        /*magFilter=*/THREE.NearestFilter, /*minFilter=*/THREE.NearestFilter);
    pointTexture.needsUpdate = true;
}

function pingPongTextureSetup() {
    const textureParams = { 
        minFilter: THREE.NearestFilter, 
        magFilter: THREE.NearestFilter,
        format: THREE.RGFormat,
        type: THREE.FloatType,
    };
    textureA = new THREE.WebGLRenderTarget( numPointsX, numPointsY, textureParams);
    textureB = new THREE.WebGLRenderTarget( numPointsX, numPointsY, textureParams);
}

function firstPassSetup() {
    firstPassScene = new THREE.Scene();
    firstPassMaterial = new THREE.ShaderMaterial( {
        uniforms: {
            pointTexture: { type: "t", value: pointTexture },
            res : {type: 'v2', value: new THREE.Vector2(numPointsX, numPointsY) },
            transform: {type: 'm3', value: new THREE.Matrix3() }
        },
        fragmentShader: document.getElementById( 'first_pass_fragmentshader' ).textContent
    } );
    
    firstPassObject = new THREE.Mesh( plane, firstPassMaterial );
    firstPassScene.add(firstPassObject);
}

function bitonicPassSetup() {
    bitonicPassScene = new THREE.Scene();
    bitonicPassMaterial = new THREE.ShaderMaterial( {
        uniforms: {
            listTexture: { type: "t", value: null },
            res : {type: 'v2', value: new THREE.Vector2(numPointsX, numPointsY) },
            kj: {type: 'v2', value: new THREE.Vector2() } // todo: how to pass int values?
        },
        fragmentShader: document.getElementById( 'bitonic_fragmentshader' ).textContent
    } );
    
    bitonicPassObject = new THREE.Mesh( plane, bitonicPassMaterial );
    bitonicPassScene.add(bitonicPassObject);
}

function setup() {
    pointTextureSetup();
    pingPongTextureSetup();
    firstPassSetup();
    bitonicPassSetup();

    //This is the basic scene setup
    scene = new THREE.Scene();
    //Note that we're using an orthographic camera here rather than a prespective
    camera = new THREE.OrthographicCamera( numPointsX / - 2, numPointsX / 2, numPointsY / 2, numPointsY / - 2, 1, 1000 );
    camera.position.z = 2;

    renderer = new THREE.WebGLRenderer();
    renderer.setSize( numPointsX, numPointsY );
    renderer.domElement.style.border = "1px solid black"; 
    document.body.appendChild( renderer.domElement );

    //Draw textureB to screen 
    finalMaterial =  new THREE.MeshBasicMaterial( {map: textureB.texture});
    let quad = new THREE.Mesh( plane, finalMaterial );
    scene.add(quad);
}

setup();

let numFramesToRender = 60; // First few frames seem to be slow.
let frameCounter = 0;

function render() {
    if (numFramesToRender > 0) {
        requestAnimationFrame( render );
        numFramesToRender--;
        frameCounter++;
    }

    // First pass - transform xyz points by a transform and store only z-value and index.
    renderer.setRenderTarget(textureB);
    renderer.render(firstPassScene, camera);

    let readFBO = textureB;
    let writeFBO = textureA;
    
    const framesToLogTiming = 120;
    if (frameCounter < framesToLogTiming) {
        console.time("bitonic dispatch");
    }
    let passCounter = 0;
    for (let k = 2; k <= numPointsX * numPointsY; k = k * 2) {
        for (let j = k / 2; j > 0; j = Math.floor(j / 2)) {
            // console.log(`k=${k} j=${j}`);
            renderer.setRenderTarget(writeFBO);
            bitonicPassMaterial.uniforms.kj.value.x = k;
            bitonicPassMaterial.uniforms.kj.value.y = j;
            bitonicPassMaterial.uniforms.listTexture.value = readFBO.texture;
            renderer.render(bitonicPassScene, camera);

            // swap buffers.
            let tmpFBO = readFBO;
            readFBO = writeFBO;
            writeFBO = tmpFBO;

            passCounter++;
        }
    }

    // Note: final FBO is the readFBO because the buffers got swapped. The final result was written
    // to writeFBO and swapped on loop exit to be in readFBO.
    const finalFBO = readFBO;

    if (frameCounter < framesToLogTiming) {
        console.timeEnd("bitonic dispatch");
        console.log(`frameCounter=${frameCounter} passes = ${passCounter}`);
    }

    // Verify that the array is sorted and the value at index is as expected (assuming transform matrix is identity).
    if (frameCounter == 0) {
        const readBuffer = new Float32Array(numPointsX * numPointsY * 2);
        renderer.readRenderTargetPixels(finalFBO, 0, 0, numPointsX, numPointsY, readBuffer);

        // console.log(readBuffer);
        
        let isSorted = true;
        let isGoodIndex = true;
        for (let i = 0; i < numPointsX * numPointsY - 1; ++i) {
            const thisIndex = readBuffer[i*2 + 1];
            const thisValue = readBuffer[i*2 + 0];
            const nextValue = readBuffer[(i+1)*2 + 0];

            if (thisValue > nextValue) {
                console.log(`Not sorted! i=${i} value[i]=${thisValue} value[i+1]=${nextValue}`);
                isSorted = false;
            }

            if (thisValue != pointBuffer[thisIndex*4+2]) {
                console.log(`Bad index! i=${i} thisIndex=${thisIndex} thisValue=${thisValue} pointBuffer[thisIndex*4+2]=${pointBuffer[thisIndex*4+2]}`);
                isGoodIndex = false;
            }

        }
        console.log(`isSorted=${isSorted} isGoodIndex=${isGoodIndex}`);
    }

    //Finally, draw to the screen
    renderer.setRenderTarget(null);
    finalMaterial.map = finalFBO.texture;
    renderer.render( scene, camera );
}
render();

       </script>
    </head>
    <body>
    </body>
</html>
